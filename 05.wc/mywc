#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'

def main
  options = parse_options
  input_source = ARGV.empty? ? { '' => ARGF.read } : read_files(ARGV)
  counts = count_content(input_source)
  counts += [count_total(counts)] if counts.size > 1
  output(counts, options)
end

def parse_options
  opt = OptionParser.new
  options = { lines: false, words: false, byte_size: false }
  opt.on('-l') { options[:lines] = true }
  opt.on('-w') { options[:words] = true }
  opt.on('-c') { options[:byte_size] = true }
  opt.parse!(ARGV)
  options = options.transform_values { true } if options.values.all?(false)
  options[:file_name] = true
  options
end

def read_files(file_paths)
  file_paths.to_h { |file_path| [file_path, File.read(file_path)] }
end

def count_content(input_source)
  input_source.map do |name, content|
    {
      lines: content.lines.size - (content.end_with?("\n") ? 0 : 1),
      words: content.split(/\s+/).size,
      byte_size: content.bytesize,
      file_name: name
    }
  end
end

def count_total(counts)
  totals = { lines: 0, words: 0, byte_size: 0, file_name: '合計' }
  counts.each do |count|
    totals[:lines] += count[:lines]
    totals[:words] += count[:words]
    totals[:byte_size] += count[:byte_size]
  end
  totals
end

def count_max_length(counts)
  integer_values = counts.last.select { |k, _| %i[lines words byte_size].include?(k) }.values
  integer_values.max.to_s.length
end

def formatted_output(counts, options, max_length, from_stdin)
  counts.each do |count|
    count.each do |key, value|
      next unless options[key]

      if key == :file_name
        print value
      elsif from_stdin && options.values.count(true) < 3
        print value
      else
        print "#{value.to_s.rjust(max_length)} "
      end
    end
    puts
  end
end

def output(counts, options)
  from_stdin = counts.last[:file_name].empty?
  max_length = from_stdin ? 7 : count_max_length(counts)
  formatted_output(counts, options, max_length, from_stdin)
end

main
